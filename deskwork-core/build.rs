use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR is set"));
    let repo_root = manifest_dir
        .parent()
        .expect("deskwork-core has workspace root parent");

    let legal_root = repo_root.join("knowledge-work-plugins").join("legal");

    println!("cargo:rerun-if-changed={}", legal_root.display());

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR is set"));
    let out_file = out_dir.join("bundled_legal_assets.rs");

    let generated = generate_assets_module(&legal_root);
    fs::write(&out_file, generated).expect("write generated bundled_legal_assets.rs");
}

fn generate_assets_module(legal_root: &Path) -> String {
    let entries = [
        ("LEGAL_PLUGIN_MANIFEST", ".claude-plugin/plugin.json"),
        ("LEGAL_PLUGIN_MCP", ".mcp.json"),
        ("LEGAL_COMMAND_BRIEF", "commands/brief.md"),
        ("LEGAL_COMMAND_RESPOND", "commands/respond.md"),
        (
            "LEGAL_COMMAND_REVIEW_CONTRACT",
            "commands/review-contract.md",
        ),
        ("LEGAL_COMMAND_TRIAGE_NDA", "commands/triage-nda.md"),
        ("LEGAL_COMMAND_VENDOR_CHECK", "commands/vendor-check.md"),
        (
            "LEGAL_SKILL_CANNED_RESPONSES",
            "skills/canned-responses/SKILL.md",
        ),
        ("LEGAL_SKILL_COMPLIANCE", "skills/compliance/SKILL.md"),
        (
            "LEGAL_SKILL_CONTRACT_REVIEW",
            "skills/contract-review/SKILL.md",
        ),
        (
            "LEGAL_SKILL_RISK_ASSESSMENT",
            "skills/legal-risk-assessment/SKILL.md",
        ),
        (
            "LEGAL_SKILL_MEETING_BRIEFING",
            "skills/meeting-briefing/SKILL.md",
        ),
        ("LEGAL_SKILL_NDA_TRIAGE", "skills/nda-triage/SKILL.md"),
    ];

    let mut output = String::from("// @generated by deskwork-core/build.rs\n");

    for (const_name, rel_path) in entries {
        let full_path = legal_root.join(rel_path);
        let content = fs::read_to_string(&full_path).unwrap_or_default();
        output.push_str(&format!(
            "pub const {const_name}: &str = {literal};\n",
            literal = to_rust_string_literal(&content)
        ));
    }

    output
}

fn to_rust_string_literal(value: &str) -> String {
    format!("{value:?}")
}
